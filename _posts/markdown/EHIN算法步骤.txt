整体算法和EFIM算法很类似，只是补充了几个计算负效用的方法，并对原方法做了一定的调整。

1. 初始化参数、变量，读取数据集，单独提取出负效用项至集合negativeItems

2. 使用utility-bin数组计算一元项的 TWU值（在算法中的方法名是计算局部效用值，但推理公式我们可以得知第一次计算的时候，局部效用值就等于一元项的TWU值）

3. 留下 TWU >= minUtil 的项，存入itemsToKeep列表（也就是Seconday(α)集）

4. 对筛选出来的项进行换名，用两个数组相互映射（这是整个代码实现中个人认为最亮点的地方，因为两个数组作换名这种结构设计极大方便了后面的项集筛选过程，而且数组为了对应数据集，数据存放都是从 下标1 开始）

5. 对itemsToKeep列表中的项按照 TWU 值进行排序（排序规则参考相应EHIN算法.md）

6. 移除（内存中物理删除）那些非高效的一元项，并在对内存中每个交易项进行扫描的过程中，标记出该交易想的第一个负效用出现的下标（negLow）（因为各项已经排好序，负效用项恒在正效用项后面，所以这里标记出来方便后续处理）

7. 按照 RTU的值 对交易表中的每个交易项进行排序，目的也是为了方便后续投影和归并操作，这里排序分三种情况分别怎么处理看代码即可。

8. 开始针对某一个项(集)进行归并交易项，期间还要移除空的交易项（比如说正好这个项集就是这条交易项的所有项，或者这条交易项中没有这个项元素）

9. 使用 utility-bin数组 计算sub-tree utility，！！！注意！！！这个计算过程不包括负效用值项（之前的negLow派上用场了）

10. 使用 itemsToExplore列表（也就是Primary(α)集）存储这些 RSU >= minUtil 的项

11. 将 Secondary集 和 Primary集 统一放入全局变量，方便后续方法调用

12. 使用迭代方法，查找高效用项集，下面进入迭代过程

a. 从Primary集中取出一个 项元素e，对该项进行交易项集投影，把该项算作前缀记录相关信息（效用值、长度、项名）对于投影这部分代码量是最大的，处理情况也是比较多，需要详细调试代码，注意变量值的变化。

b. 当投影结束后，判断该像是否为高效用项，如果该项效用值大于（注意没有等于）阈值，那么还要判断加上负效用项后它的效用值是不是大于阈值

c. 计算加入负效用项的上界，重置SU数组，遍历投影交易项集

d. 与计算正效用项SU一样，判断负效用项的SU >= minUtil，成立就加入 promisingNegativeItems，并带入计算高效用项集，未完待续。。。