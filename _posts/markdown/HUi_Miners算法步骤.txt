1. 先计算各一元项的TWU值，并删除那些TWU < minUtil的项（之后的计算不考虑这些项，因为你本身就是低效用，与其他项组合的机会更少，所以组合出来的项的效用值也会更低，可以参考频繁项挖掘：比如说A商品是非频繁的，那么它与频繁的B商品能组合的概率就很低【意味着组合出来的一定是非频繁的】，更不用说和那些非频繁的组合了）

2. 按照TWU对各初步筛选的项进行排序，怎么排可以自己定义

3. 调整交易项：
	首先，把各条交易项进行内部的排序（顺序按照上一条定义的顺序排）
	其次，按照TU值对各交易项进行排序，一般是从大到小

4. 根据修正后的交易项，构造utility-list：从一元项utility-list开始构造起，每个utility-list是由一个或多个元组构成，具体形式为（Tid，Iutil，Rutil），针对每个一元项的utility-list，Tid就是这个项在哪个交易项里出现过，Lutil就是该项在该条交易项中的效用值，Rutil就是在该条交易项中所有大于该项的项的效用值之和（因为之前已经排好序了）

5. 以一元项utility-list为基础构造二元项集utility-list（就像之前的频繁项集挖掘算法生成的候选集一样），从两个不同的一元项utility-list中查找有没有同一条交易项（看Tid），有的话就进行合并（每条交易项也是排好序的，所以两两比较很快的）合并规则很简单：Tid维持不变，Iutil值等于两者相加，Rutil值等于小的那个（为什么呢？因为这是已排序状态，好比在交易项T1中，A后面还有四个项，B还有两个项，AB合并后后面是不是只有两个项了？）这合并出来的utility-list就是一个新的了

6. 同理，三元项utility-list从二元项utility-list中合并得出，但这里要注意一点，因为共同前缀的关系，前缀会被重复计算一次，所以我们要删除这部分的值，再者该算法是增长模式，也就是一次就只扩展一个项，不会一次性扩展多个项

--------其实这里面就已经涉及到共同前缀关系了---------

7. 每选出一次n元utility-list后，把该utility-list的Iutil这一列值相加，得到的就是该项（集）的效用值，选出效用值大于minUtil的项（集）即可

8.本算法把遇到的最大问题用枚举树很形象的表示出来了，可以看得出来随着一元项的增多，其能组合产生的项集也是越来越多，这样就犯了和频繁项集挖掘算法产生大量候选集一样的错误。为此用到剪枝策略，同样用到了TWU的特性：项集X的TWU < minUtil时，它的扩展项集（超集）的TWU一样会 < minUtil。但多元项集的TWU怎么计算呢？这就是设计utility-list的优越之处了，只要把该项集的utility-list中的所有Iutil和Rutil值全部相加，就是该项的TWU值（证明过程可以看论文）

9. 论文中还提了一个小技巧，其实没必要为每个项集都专门设置一个utility-list，可以充分利用共同前缀的信息来计算扩展集