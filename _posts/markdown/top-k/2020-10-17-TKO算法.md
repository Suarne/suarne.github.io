写在前面：这篇文献里其实包含了两个算法：TKU（Two-phase algorithm，基于 Up-Growth 算法改进）和TKO（One-phase algorithm），分别讨论了这两篇算法的差异和优劣。

# Efficient Algorithms for Mining Top-K High Utility Itemsets

## 样本

**数据集：**

![Transaction Database](/assets/img/algorithm/TKO算法/transaction database.png)

**各项利润值：**

![External Utility](/assets/img/algorithm/TKO算法/external utility.png)

## 定义

+ 交易数据集（**Transaction Dataset**）：设 $I= \{x_1, x_2, \cdots, x_m\}$ 是许多不同项的集合，项集 $X \subseteq I$，其中项/项集 $X \supseteq T_j$，交易数据集 $DB = \{T_1, T_2, \cdots, T_n\}$

+ 内部效用值（**Internal Utility**）：也可以看作数量，设 $\exists x \in I, T_j \in DB$，$q(x, T_j)$ 意味着在交易项 $T_j$ 中，项 _x_ 的出现次数，可以参考样例中的 Table 1

+ 外部效用值（**External Utility**）：也可以看作利润，设 $\exists x \in I$，$p(x)$ 意味着该项的利润值，可以参考样例中的 Table 2

+ 在交易项中的项/项集效用值（**Utility of item/itemset in Transaction**）：对于某个交易项 $T_j$ 中的项 _x_（或项集 _X_）有 $u(x, T_j) = p(x) \times q(x, T_j)$，同理 $u(X, T_j) = \sum_{x \subseteq X}u(x)$，效用值是一个重要的参考指标，它可以衡量一个事务对于使用者的价值到底有多重要。通常情况下，我们认为效用值越大越重要

+ 在数据集中的项/项集效用值（**Utility of item/itemset in Dataset**）：对于整个数据集 _DB_ 中的项 _x_（或项集 _X_）有 $u(x) = \sum_{x \in T_j}u(x, T_j)$，同理 $u(X) = \sum_{X \subseteq T_j}u(X, T_j)$

+ 高效用项（**High Utility item**）：当某个项被称为 _x_ 高效用项即意味着该项是我们所需要的，即它的效用值大于（或等于）我们设定的最低阈值（$u(x) \ge minUtil$），原文中用的是相对效用值（比率形式）

+ 交易项效用值（**Utility of Transaction**）：对于交易项我们也设定一个效用值 $TU(T_j) = \sum_{x \in T_j}u(x, T_j)$，交易项的效用值也可以看作每个项/项集的重要程度衡量参考，在后续 _TWU_ 定义中会有更详细的解释

+ 交易项权重效用值（**Transaction Weighted Utilization**）：交易项权重效用值（**_TWU_**）表现的是一个项/项集的潜在价值，即该项/项集与其它项结合能够产生新的高效用项集（**HUIs**），**_TWU_** 数值越大，意味着该项能与越多的项组成 _HUI_，计算公式如下：$TWU(x) = \sum_{x \in T_j}TU(T_j)$（项和项集的计算公式一样）当一个项/项集的 **_TWU_** 值大于 _minUtil_ 时，我们就要把该项/项集纳入考虑范围（即与其它项组合有没有可能生成新的高效用项集）

  Ps. TWU的作用在整个算法中还是很重要的，因为它具备 **_TWDC_**（反单调性，目的与频繁项集挖掘一致），对整个项集和交易项的排序、裁剪有很大作用，有以下性质：
  
  > 1. 基于剪枝计算TWU：因为 TWU(x) \ge u(x)，当 TWU(X) < minUtil 时，可以认为这个项集和它的扩展集不可能是高效用项集

+ Top-$k$高效用项集（**Top-$k$ high Utility itemset**）：该项集是一个列表，里面存放着当前 _k_ 个高效用项集，每个项集的效用值都大于当前的最低阈值（**minUtil**）

## TKU算法
该算法基于 $UP-Tree$ 结构，通过 $TWU$ 来对树进行剪枝（删除掉低效用的项），但属于 $Two-phase$ 类别的算法，效率上要低一些。关于 _Up-Tree_ 数据结构介绍可以参考 [FP-Growth](https://juejin.im/post/6883290309980061704) 这篇文章

### 策略

#### PE

#### NU

#### MD

#### MC

#### SE

## TKO算法
该算法基于 $Utility-List$ 结构，通过 $vertical data structure$ 来对树进行剪枝（矩阵？），但属于 $One-phase$ 类别的算法，效率上要更高

### 策略

#### RUC

#### RUZ

#### EPB

### 1.The Search Space

和其它算法一样，也采用枚举树结构来操作，使用深度遍历方法，根节点为空，对所有的项以TUW值的大小进行升序排列

#### 补充定义

+ 项扩展（Extension of an item）：设 α 是一个项集，可用于扩展项集  α 的项组成的集合我们称为项扩展 $E(\alpha) = \{z | z \in I \land z \succ x, \forall x \in \alpha\}$（翻译一下就是在一个交易项中大于项集 α 的项组成的项集）
+ 项集扩展（Extension of an itemset）：设 α 是一个项集，Z 是 α 的扩展（出现在 α 的子枚举树中），当 $Z = \alpha \cup W, W \in 2^{E(\alpha)}$ 时，Z 是 α 的一元扩展项，出现在 α 的子枚举树中；当 Z = α ∪ {z}，z ∈ E(α) 时，Z 是 α 的多元扩展项

### 2.Concept of co-occurrence structure

在 top-k-HUIs mining 算法中最关键的就是如何让 minUtil 高效地自动增长，文中设计了一种叫 EUCST（Estimated Utility Co-occurrence Pruning Strategy with Threshold）的方法，可以同时达到增长 minUtil 和检索空间剪枝的效果

#### 定义

+ EUCS structure：是一系列元组结构，形如 $(x, y, z) \in I^* \times I^* \times \mathbb{R}^+$，同时 (x, y, z) 定义为 TWU({x, y}) = z

  例如查看Table 8 中的 第一个交易项， TWU({A, D}) = 37、TWU({D, B}) = 58

  ![Final EUCS Map](/assets/img/algorithm/TKO算法/Final EUCS Map.png)

  > 设 X 是项集，当 TWU(X) < minUtil 时，对于项集 X 的任何扩展 y∈Y，都有 U({Y, X}) < minUtil

  从上图来看 EUCS 结构是一种三角矩阵，但在代码实现中使用的时 hashMap，EUCS 结构只存储 TWU ≠ 0 的值。本算法第一次扫描数据集的时候计算出所有一元项的 TWU，然后进行升序排序，如Table 4：

  ![排序后的一元项](/assets/img/algorithm/TKO算法/按照TWU排序后的各项.png)

  第二次扫描构建 EUCS 结构，表格中的每个单元表示该项集的 TWU 值，如Table 5，6：

  ​                     【以下几张表中的交易项和 Table 2 冲突了，那么 Table 3 在这也不适用】

  ![](/assets/img/algorithm/TKO算法/EUCS map for transaction T1.png)

  Ps. T1=(A, 4), (D, 4), (B, 6), (E, 3)，在这个表中可以得到以下元组：(A,D, 17), (A, B, 17), (A, E, 17), (D, B, 17), (D, E, 17), (B, E, 17)

  ![](/assets/img/algorithm/TKO算法/EUCS map up-to transaction T2.png)

  Ps. T2 = (F, 6), (C, 5), (B, 3), (E, 1)，同样可以得到以下元组(F, C, 15), (F, B, 15), (F, E, 15), (C, B, 15), (C, E, 15), (B, E, 15)，很明显(B, E, 15)已经存在，那我们只要把值叠加即可

  经过不断叠加至所有交易项都算完，可得 Table 7：

  ![](/assets/img/algorithm/TKO算法/EUCS Map with all TWU.png)

  最后删除那些小于minUtil的值，得到最终结果 Table 8：

  ![](/assets/img/algorithm/TKO算法/Final EUCS Map.png)

### 3.Dataset scanning techniques

  基于 EUCS结构 的剪枝被称为 EUCP，本算法也涉及到映射和归并技术

  #### 数据集投影

补充定义

+ 数据集投影（Projected Dataset）：项集 α 在某个交易项上的投影设定为 α-T = {i | i ∈ T 且 i ∈ E(α)}；项集 α 在数据集 D 上的投影设定为 α-D = {α-T | T ∈ D 且 α-T ≠ null}

#### 交易项归并

在投影结束后，可能会产生某些不同的交易项投影出来的项一致（项的IU可能不一样），为此本文将这些相同地交易项合并成一条，减少扫描次数

补充定义

+ 交易项归并（Transaction Merging）：设存在多个交易项 $T_{a1} = T_{a2} = \cdots = T_{am}$，则用 $T_M$ 来统一表示这些交易项，有 $\forall x \in T_M, IU(x, T_M) = \sum_{j = 1\cdots}IU(x, T_{aj})$ 

### 4.Threshold raising strategies

#### RIU strategy

![Real item utilities](/assets/img/algorithm/TKO算法/RIU strategy.png)

该方法是由 REPT算法 提出的，全称是 Real item utilities。在第一轮扫描数据集的时候，计算 $\sum_{T_j \in D}U(x, T_j)$ 的同时也把值存入 RIU(x) 中，以列表的形式存储这些值，并对其做升序排列。然后，RIU方法将minUtil提高到排序后的RIU列表中的第k个最大值，这个值就是现在设定的阈值，直到有其它方法提高了阈值

#### CUD strategy

![CUD strategy](/assets/img/algorithm/TKO算法/CUD strategy.png)

该方法是由 kHMC算法提出的，通过利用 EUCS结构 里的二元项集效用值来增加minUtil，EUCS结构包含一对TWU值大于 minUtil 的项，因此可能是一个高效用项集。为此，可以考虑再度提高阈值（使用CUD方法）用于存储这对项效用值的结构称为 CUD效用矩阵（CUDM），CUD方法是在RIU方法之后执行的。

#### COV strategy

![Coverage strategy](/assets/img/algorithm/TKO算法/COV strategy.png)

该方法全称是 Coverage strategy，该方法使用COVL（coverage list）结构来成对存储项的效用值

### 5.Pruning strategies

基于EFIM算法的sub-tree utility剪枝策略改进版，命名为 EUCP

定义

+ Pruning using EUC (EUCP)：设项集 X，若 TWU(X) < minUtil，那么对于任意项集 X 的扩展项 Y，有 U(XY) < minUtil

+ Sub-tree Utility（SU）：设项集 α，且有项 x ∈ E(α) 在深度遍历项集过程中能够成为其子树，有 $SU(\alpha, x) = \sum_{T \in (\alpha \cup \{x\})}[U(\alpha, T) + U(x, T) + \sum_{i \in T \land i \in E(\alpha \cup \{x\})}U(i, T)]$

  > 设项集 α，且有项 x ∈ E(α) ，其中 $SU(\alpha, x) \ge U(\alpha \cup \{x\})$
  >
  > 设项集 z = x ∪ y，则有关系 $TWU(z) = EUCP(x, y) \ge REU(z) = su(x, y)$ 成立

+ Secondary(α)：最开始由TWU(α)【 α 是一元项】值组成，计算公式为 
  $Secondary(\alpha) = \{x | x \in E(\alpha) \land TWU(\alpha, x) \ge minUtil\}$

+ Primary(α)：最开始由SU(α)【 α 是一元项】值组成，计算公式为
  $Primary(\alpha) = \{x | x \in E(\alpha) \land SU(\alpha, x) \ge minUtil\}$

  > 因为有 $TWU(\alpha, x) \ge SU(\alpha, x)$，所以 $Primary(\alpha) \subseteq Secondary(\alpha)$ 成立

### 6.Calculate upper bounds using utility array

同EFIM一样，本文也使用了Utility Array结构，对每个交易项的每个项进行同层、上下累加计算，算完最后一个交易项时，有 $TWU(x) = UA[x] = SU(x)$，计算公式分别为：

$ TWU：UA[x] = UA[x] + TU(x, T_j), x \in I \\ SU：UA[x] = UA[x] + U(\alpha, T) + U(x, T) + \sum_{i \in T \land i \in E(\alpha \cup \{x\})}U(x, T), x \in E(\alpha)$

### 7.Main procedure of TKEH

以下是算法的核心部分伪代码：

<img src="/assets/img/algorithm/TKO算法/TKEH algorithm.png" alt="TKEH algorithm" style="zoom:80%;" />

<img src="/assets/img/algorithm/TKO算法/The Search algorithm.png" alt="The Search algorithm" style="zoom:75%;" />

# 参考

> 1. Kuldeep Singh、Shashank Sheshar Singh、Ajay Kumar、Bhaskar Biswas: Efficient Algorithms for Mining Top-K High Utility Itemsets-
>    [https://xueshu.baidu.com/s?wd=paperuri:%28c3b6b3ec57da8151d54a7a449a368c4a%29&filter=sc_long_sign&tn=SE_xueshusource_2kduw22v&sc_vurl=http://ieeexplore.ieee.org/document/7164333/&ie=utf-8&sc_us=15059615029795794754](https://xueshu.baidu.com/s?wd=paperuri:(c3b6b3ec57da8151d54a7a449a368c4a)&filter=sc_long_sign&tn=SE_xueshusource_2kduw22v&sc_vurl=http://ieeexplore.ieee.org/document/7164333/&ie=utf-8&sc_us=15059615029795794754)
> 2. Top-k高效用项集挖掘_学习笔记(一) 基础概念:  Erpim-https://blog.csdn.net/qq_35414569/article/details/79969585
> 3. Top-k高效用项集挖掘_学习笔记(二) TKU:  Erpim-https://blog.csdn.net/qq_35414569/article/details/79991520
> 4. Top-k高效用项集挖掘_学习笔记(三) TKO: Erpim-https://blog.csdn.net/qq_35414569/article/details/80053130


2020-10-18

本周主要工作

+ 完成TopHUI、TOPIC算法测试及数据整理

下周计划安排

+ 完成TOPIC算法论文
+ 分析 FP-Growth 算法代码
